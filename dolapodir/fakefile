job('my-newjob')
label
description
publishers-contains all the publisher actions.
dsl methods can be cumulative or overriding, meaning that some methods will add nodes (e.g.),
publishers and steps. and will replace nodes (e,g) disabled will replace any existing disabled nodes). some methods like scm
and multiscm are mutually exclusive. likewise, when using the scm block, only one scm can be specified.

when using these methods, remember that you need to use them in context. e.g to use the downstream method, it
needs to be enclosed in a publishers context.

The plugin tries to provide DSL methods to cover "common use case" scenarios as simple method calls.
when these methods fail you, you can always generate the underlying XML yourself via the configure block.

def myJob = freeStyleJob('SimpleJob')
myJob.with {
   description 'A Simple Job'
  }

  when the configfile provider plugin has been installed, the dsl can be used to create configuration files.

the configFiles method can be used to create any kind of config file that is supported by the dynamic dsl.

Use the embedded API viewer to browse available methods.

the other methods behaves like the job methods and will return a config file object, but these methods are deprecated
and will be removed.

config files will be created before jobs to ensure that the file exists before it is referenced.

customConfigFile('my-config') {
  comment('My important configuration')
  content('<some-xml/>')
}

mavenSettingsConfigFile('central-mirror') {
  content readFileFromWorkspace('maven-settings/central-mirror.xml')
}

  Queue
  queue(String jobName)
  queue(Job job)

  this provide the ability to schedule a job to be executable after the DSL runs.

  This provide the ability to schedule a job to be executable after the dsl runs.  The given name doesn't
  have to be a job which was generated by the DSL, but it could be.

  InputStream streamFileFromWorkspace(String filePath)
  String readFileFromWorkspace(String filePath)
  String readFileFromWorkspace(String jobName, String filePath) // since 1.25

....with the first two variants, you can read in a file from the current workspace anywhere in the script.
This asumes that you checked out some source control as part of the job processing the DSL. This can be useful when
populating fields on a generated job, e.g.

job('example') {
    steps {
        shell(readFileFromWorkspace('build.sh'))
    }
}

And with the third variant,you can read a file from the workspace of any job. This can be used to set the
description of a job from a file in the job's workspace. the method will return null when the jov or the file
does not exist or the job has no workspace, e.g. when it has not been built yet.

job('acme-tests') {
    description(readFileFromWorkspace('acme-tests', 'README.txt'))

}

Uploading User Content
Jenkins has a mechanism called user content, which allow arbitary files to be served from
http://yourhost/jenkins/userContent

User content can be uploaded to jenkins with the userContent DSL method.

userContent(String path, InputStream content)

In conjunction with streamFileFromWorkspace, any content can be uploaded fro the seed job's workspace.

userContent('acme.png', streamFileFromWorkspace('images/acme.png'))

